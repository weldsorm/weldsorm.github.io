<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Welds Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Welds Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-welds-orm-programming-book"><a class="header" href="#the-welds-orm-programming-book">The Welds ORM Programming Book</a></h1>
<p>by Lex Childs, with contributions from the Rust Community</p>
<p>This version of the text is for the latest stable version of the Welds ORM library.</p>
<p>The source for this book is hosted on github at <a href="https://github.com/weldsorm/book">https://github.com/weldsorm/book</a>.
Contributions to this book are very welcome and appreciated. Clarifying a single poorly worded sentence can make a big difference to the people who read this book after you.</p>
<p>Welds Supports</p>
<ul>
<li>Sqlite</li>
<li>MySql</li>
<li>Postgres</li>
<li>Mircosoft Sql Server (mssql)</li>
</ul>
<h1 id=""><a class="header" href="#"></a></h1>
<p>Welds is an ORM written in rust with the following ideals:</p>
<ul>
<li>Your Welds code should be simple, easy to read and easy to write.</li>
<li>Your welds code should work across all supported databases.</li>
<li>You should always be able to drop down to SQL if you need.</li>
<li>All database calls should be async</li>
</ul>
<h3 id="relevant-links"><a class="header" href="#relevant-links">Relevant links</a></h3>
<ul>
<li><a href="https://github.com/weldsorm/welds">Welds on GitHub</a></li>
<li><a href="https://crates.io/crates/welds">Welds on Crate.io</a></li>
<li><a href="https://docs.rs/welds/latest/welds/">Welds on docs.rs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ul>
<li><a href="./setup.html">Project Setup</a></li>
<li><a href="./connections.html">Database Connections</a></li>
<li><a href="./fundamentals.html">Fundamentals Struct/Traits</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<p>For the most part there isn't really much extra you need to do over a normal crate.
It is recommended to install Welds with a simple cargo add command, but you will need to pick your database backends you want to support.
These are enabled as features on the Welds crate.</p>
<p>You will also need to setup <code>SQLx</code> or <code>Tiberius</code> as well. <code>Tiberius</code> for Microsoft SQL Server and SQLx for the other backends.
This has been left up to you because these library support multiple async backends and you need to pick which one to use.</p>
<p>You can also add more features as you need, but a couple simple examples would be:</p>
<h3 id="welds-compiled-for-sqlite"><a class="header" href="#welds-compiled-for-sqlite">Welds compiled for Sqlite</a></h3>
<pre><code class="language-bash">cargo add welds --features="sqlite"
cargo add sqlx --features="runtime-tokio"
</code></pre>
<h3 id="welds-compiled-for-postgres"><a class="header" href="#welds-compiled-for-postgres">Welds compiled for Postgres</a></h3>
<pre><code class="language-bash">cargo add welds --features="postgres"
cargo add sqlx --features="runtime-tokio,tls-rustls"
</code></pre>
<h3 id="welds-compiled-for-microsoft-sql-server"><a class="header" href="#welds-compiled-for-microsoft-sql-server">Welds compiled for Microsoft Sql Server</a></h3>
<pre><code class="language-bash">cargo add welds --features="mssql"
cargo add tiberius
</code></pre>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<p>For external extra types you will need to enable them in the underlying database driver.</p>
<h3 id="welds-compiled-for-sqlite-with-chrono-support"><a class="header" href="#welds-compiled-for-sqlite-with-chrono-support">Welds compiled for Sqlite with chrono support</a></h3>
<pre><code class="language-bash">cargo add welds --features="sqlite"
cargo add sqlx --features="runtime-tokio,chrono"
</code></pre>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<p>For external extra types with Mssql you will need to enable them in welds-connections too.</p>
<h3 id="welds-compiled-for-sqlite-and-microsoft-sql-server-with-chrono-and-uuid-support"><a class="header" href="#welds-compiled-for-sqlite-and-microsoft-sql-server-with-chrono-and-uuid-support">Welds compiled for Sqlite and Microsoft Sql Server with chrono and uuid support</a></h3>
<pre><code class="language-bash">cargo add welds --features="sqlite,mssql"
cargo add sqlx --features="runtime-tokio,chrono,uuid"
cargo add tiberius --features="chrono"
cargo add welds-connections --features="mssql,sqlite,mssql-chrono"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<p>Before diving to deep into Welds, there are a couple constructs you should be aware of.
These are the four most common things you will see when interacting with Welds.</p>
<p>Infact, This is what is included when you add the line.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use welds::prelude::*;
<span class="boring">}</span></code></pre></pre>
<p>which you should do.</p>
<h2 id="weldsclient"><a class="header" href="#weldsclient">welds::Client</a></h2>
<p>This is the trait that is implemented by All the backend pools and all the backend transaction types.</p>
<p>It is common to see this trait passed into your function that does database calls.</p>
<p>With this trait you can execute SQL and get data back, however you typically don't call it directly.</p>
<h2 id="weldstransactstart"><a class="header" href="#weldstransactstart">welds::TransactStart</a></h2>
<p>This trait is implemented by All the backend pools.</p>
<p>It is used to start a transaction. It is almost always the same object as the Client.</p>
<p>You can use it to start a transaction by calling <code>begin()</code></p>
<p>NOTE: transactions are automatically rolled back unless you call <code>commit()</code></p>
<h2 id="weldsdbstatet"><a class="header" href="#weldsdbstatet">welds::DbState&lt;T&gt;</a></h2>
<p>This is a wrapper around your model. While you might not use this struct directly, it is what is returned to you from a database query. It works very similar to <code>std::sync::MutexGuard</code>, transparently giving you access to the model inside.
It is used by welds to keep track of the changes you make to your model so Welds can create or update it in the database.</p>
<p>If you are finished with Welds and just want your vanilla model back, you can call <code>into_inner</code> or <code>into_vm</code> to get to the inner object.</p>
<h2 id="weldsmodel"><a class="header" href="#weldsmodel">WeldsModel</a></h2>
<p>The Attribute you will add to your models. <a href="models.html">More information can be found here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connections"><a class="header" href="#connections">Connections</a></h1>
<p>Connections in welds are done using the crate <code>welds-connections</code>. This crate is re-exported out of welds for ease of use.
<code>welds-connections</code> is a common interface that allows for talking to different databases in a common way.</p>
<p>You can create a database client for a specific database backend, but generally It is recommended to use the generic connection that supports whatever backends you have enabled.
To do this you make a call into welds connections passing a connection_string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connection_string = "sqlite::./database.sqlite";
let client = welds::connections::connect(connection_string).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="client"><a class="header" href="#client">Client</a></h2>
<p>A couple important things to understand about the client.</p>
<ol>
<li>Client is an <code>Arc&lt;&gt;</code> feel free to call <code>clone()</code> on it as much as you want.</li>
<li>Client is a Connection Pool. It contains multiple connections and will handle sharing this resource for you.</li>
</ol>
<h2 id="connection-string"><a class="header" href="#connection-string">Connection String</a></h2>
<p>Connection string follow the format of there corresponding database backends.</p>
<p>For SQLx you use a URL style connection string with the database backend being the protocol.</p>
<p>Valid backends are</p>
<pre><code>postgres://
mysql://
sqlite://
</code></pre>
<p>And follow the format:</p>
<pre><code>postgres://[user[:password]@][host][:port][/dbname][?params]
</code></pre>
<p>Microsoft SQL Server uses the ADO.NET style connection that they have documented <a href="https://learn.microsoft.com/en-us/sql/connect/ado-net/connection-string-syntax?view=sql-server-ver16">here</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// export DATABASE_URL='server=127.0.0.1;user id=sa;password=password!123;Database=AdventureWorksDW2022;TrustServerCertificate=true;'
let connection_string = env::var("DATABASE_URL").unwrap();
let client = welds::connections::connect(connection_string).await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models"><a class="header" href="#models">Models</a></h1>
<p>Models are the heart of Welds. All queries are made off of the models you define.
Additionally models are used to de-serialize rows from the database,
so they might not always represent corresponding tables or views.</p>
<p>Relationships are also defined on your models.
These relationships allow for complex queries like joins and sub-queries.</p>
<h1 id="basic"><a class="header" href="#basic">Basic</a></h1>
<p>At its very simplest all that is needed is a <code>#[derive(WeldsModel)]</code>. This derive gives you basic deserialization.
If you are working with other models, and selecting into a basic struct, that might be all you need. but most likely you will want a little more.
A better basic example would be as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(WeldsModel)]
#[welds(schema = "dto", table = "pets")]
pub struct Pet {
    #[welds(primary_key)]
    pub id: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>This model is fully functional. It can be loaded from the database; saved to the database; or queried in the database.</p>
<p>For example a basic query might look something like this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pets = Pet::all().where_col(|x| x.id.not_equal(42)).run(client.as_ref()).await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>This is a list of Attributes you can add to your welds model to help control how it is wired up.</p>
<h2 id="struct-level-attributes"><a class="header" href="#struct-level-attributes">Struct Level Attributes</a></h2>
<h3 id="table-links"><a class="header" href="#table-links">Table Links</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(table = "tablename")]
// or 
#[welds(schema="schemaname", table = "tablename")]
<span class="boring">}</span></code></pre></pre>
<p>Link a model to a table.<br />
If a model is a one-to-one, or a subset of a table, add this on to it so that You can query directly off of the model.</p>
<h3 id="readonly"><a class="header" href="#readonly">Readonly</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(readonly)]
<span class="boring">}</span></code></pre></pre>
<p>Mark a model as being readonly. Useful when wiring up views or other read only objects. This prevents the save code from being generated in the derive</p>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(BelongsTo(team, Team, "team_id"))]
#[welds(HasMany(players, Player, "team_id"))]
#[welds(HasOne(profile, Profile, "profile_id"))]
#[welds(BelongsToOne(user, User, "profile_id"))]
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="./model_relationships.html">Relations section</a> for more details</p>
<h3 id="hooks"><a class="header" href="#hooks">Hooks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(BeforeCreate(func))]
#[welds(AfterCreate(func))]
#[welds(BeforeUpdate(func))]
#[welds(AfterUpdate(func))]
#[welds(BeforeDelete(func))]
#[welds(AfterDelete(func))]
<span class="boring">}</span></code></pre></pre>
<p>Hooks. See the <a href="./model_hooks.html">Hooks section</a> for more details</p>
<h2 id="field-level-attributes"><a class="header" href="#field-level-attributes">Field Level Attributes</a></h2>
<h3 id="primary-key"><a class="header" href="#primary-key">Primary key</a></h3>
<pre><code>#[welds(primary_key)]
</code></pre>
<p>Lets welds know which field is the primary_key of the table/view.</p>
<p>This is needed for:</p>
<ul>
<li>find_by_id</li>
<li>Creating / Updating / Deleting</li>
<li>Relationships</li>
</ul>
<h3 id="rename"><a class="header" href="#rename">Rename</a></h3>
<pre><code>#[welds(rename="new_name")]
</code></pre>
<p>Add This to a field when the field's name doesn't match the name in the database</p>
<h3 id="ignore"><a class="header" href="#ignore">Ignore</a></h3>
<pre><code>//  #[welds(ignore)]
</code></pre>
<p>Sometimes you need to have a little extra state or other stuff attached to your model.
This tells welds that this field has nothing to do with the database and should be ignored.</p>
<p>If you can, It is useful to make this field <code>Default</code>. That way welds can really ignore it all the way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-added-to-your-model"><a class="header" href="#whats-added-to-your-model">Whats Added To your Model</a></h1>
<p>When you use the Welds ORM derive on your struct, it automatically provides several methods to help you create, retrieve, query, and manage data. Here’s an overview of those methods:</p>
<br/>
<h2 id="yourmodelnew"><a class="header" href="#yourmodelnew">YourModel::new()</a></h2>
<p>Purpose: Creates a new instance of the model in memory (not yet inserted into the database).
call <code>save()</code> to insert into the database.</p>
<p>Usage:</p>
<pre><code>let mut model = YourModel::new();
model.save(client.as_ref()).await?;
</code></pre>
<p>Typical Use Cases:</p>
<ul>
<li>Create an empty model to fill with data.</li>
<li>Prepare a model before saving to the database.</li>
</ul>
<p>Alternatives:
Sometimes you want to compile time check that all fields have values. In this case it is recommended to create your new instance with state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut model = DbState::new_uncreated(Model {
  id: 0, /* A default value like 0 will be filled in from database */
  name: "Bobby".to_owned(),
});
model.save(client.as_ref()).await?;
// The new id is updated on the model.
assert_eq( model.id, 1);
<span class="boring">}</span></code></pre></pre>
<br/>
<br/>
<br/>
<h2 id="yourmodelall"><a class="header" href="#yourmodelall">YourModel::all()</a></h2>
<p>Purpose: Returns a query (un-executed) of all rows in the table.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = YourModel::all();
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Cases:</p>
<ul>
<li>Starting place for querying a table.</li>
<li>Starting place for querying a related table using <code>map_query</code>.</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="yourmodelfind_by_id"><a class="header" href="#yourmodelfind_by_id">YourModel::find_by_id()</a></h2>
<p>Purpose: Finds a single record by its primary key ID.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let id = 42;
let maybe_record = YourModel::find_by_id(client.as_ref(), id).await?;
if let Some(record) = maybe_record {
    // Found the record with ID = 42
} else {
    // No record with that ID
}
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case:</p>
<ul>
<li>Retrieve a single row when you know its primary key.</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="yourmodelwhere_col"><a class="header" href="#yourmodelwhere_col">YourModel::where_col()</a></h2>
<p>Purpose: Returns a query (un-executed) of a filtered set of rows in the table.</p>
<p><a href="./query_basic.html">You can read a detailed explanation of basic queries here</a></p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = YourModel::where_col(|col| col.name.equal("some_name"));
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Cases:</p>
<ul>
<li>Starting place for querying a table.</li>
<li>Starting place for querying a related table using. <code>map_query</code>.</li>
<li>Used to pass into other queries to help filter them more. (sub-query) <code>where_relation</code></li>
</ul>
<br/>
<br/>
<br/>
<h2 id="yourmodelfrom_raw_sql"><a class="header" href="#yourmodelfrom_raw_sql">YourModel::from_raw_sql()</a></h2>
<p>Purpose: Execute custom or raw SQL that maps directly to your model fields.</p>
<p>It is recommended to avoid if you can, but it is recognized that welds doesn't do everything and sometimes you just need raw SQL.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = "bobby".to_string();
let params: welds::query::clause::ParamArgs = vec![&amp;42, &amp;name];
let profiles = Profile::from_raw_sql(
    "select * from profiles where id &gt; ? OR name = ?",
    &amp;params,
    client.as_ref(),
)
.await?;
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Cases:</p>
<ul>
<li>Complex queries not easily expressed with the provided query builder.</li>
<li>Performing specialized joins, aggregates, or database-specific functionality, while still returning YourModel items.</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="yourmodelselect"><a class="header" href="#yourmodelselect">YourModel::select()</a></h2>
<p>Purpose: Starts a customizable “select” query builder for this model.
This is used to return a sub-set of your columns on your model. You can also start a "select" query off of any query such as where_col.</p>
<p><a href="./query_select.html">You can read a detailed explanation of select queries here</a></p>
<p><em><strong>NOTE: You will want a second model that represents your subset of columns</strong></em></p>
<p>Usage:</p>
<p>Subset Model</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Because all you need is deserealization. All you need to add is WeldsModel

#[derive(WeldsModel)]
pub struct IdAndName {
    pub id: i32,
    pub name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>Query filling your subset model</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = YourModel::select(|x| x.id).select(|x| x.name);
let data: Vec&lt;IdAndName&gt; = query.run(client.as_ref()).await?.collect_into()?;
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Cases:</p>
<ul>
<li>When you want only some of the data from your table.</li>
<li>When you want columns of data across table. (Join / Left Join)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-update-and-delete"><a class="header" href="#create-update-and-delete">Create, Update, And Delete</a></h1>
<p>When you get data back from the database it is typically wrapped in DbState like this.</p>
<pre><code>let mut pet: DbState&lt;Pet&gt; = Pet::find_by_id(42).run(client.as_ref()).await?;
</code></pre>
<p>DbState is how welds knows what to do with your models.</p>
<p>The compiler knows how to automatically treat a DbState as a borrowed version of its inner type.
This means for the most part you shouldn't need to refer to DbState much, just the borrowed type.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn give_dog_treat(&amp;mut dog: Pet) {
    dog.wags += 1;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pet: DbState&lt;Pet&gt; = Pet::find_by_id(42).run(client.as_ref()).await?;
give_dog_treat(&amp;pet);
<span class="boring">}</span></code></pre></pre>
<br/>
<br/>
<p><em><strong>DbState is required to Create, Update, or Delete the instance of your model in the database.</strong></em></p>
<p>Saving can always be done by calling. <code>save()</code>.
Save will create or update based on the states knowledge of what is in the database.
Additionally <code>delete</code> can be called to execute a SQL delete command.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pet: DbState&lt;Pet&gt; = Pet::find_by_id(42).run(&amp;client).await?;
give_dog_treat(&amp;pet);
pet.save(&amp;client).await?;
<span class="boring">}</span></code></pre></pre>
<br/>
<br/>
<br/>
<br/>
<h2 id="removing-dbstate"><a class="header" href="#removing-dbstate">Removing DbState</a></h2>
<p>A very common use case is to fetch some data and then display, or do something with it that doesn't involve the database.
When this happens it is often nice to not have to worry about DbState.
Welds provides several ease of use functions to help remove DbState when you want just the Underlying Model.</p>
<br/>
<h3 id="single-instances"><a class="header" href="#single-instances">Single Instances</a></h3>
<h4 id="into_inner"><a class="header" href="#into_inner">into_inner()</a></h4>
<p>returns the inner Model stripped of DbState.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pet_with_state: DbState&lt;Pet&gt; = Pet::find_by_id(42).run(client.as_ref()).await?;
let pet: Pet = pet_with_state.into_inner();
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case:</p>
<ul>
<li>Interacting with other code non-welds related.</li>
</ul>
<br/>
<h4 id="into_vm"><a class="header" href="#into_vm">into_vm()</a></h4>
<p>returns the inner Model stripped of DbState and wrapped in Arc.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pet_with_state: DbState&lt;Pet&gt; = Pet::find_by_id(42).run(client.as_ref()).await?;
let pet: Arc&lt;Pet&gt; = pet_with_state.into_vm();
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case:</p>
<ul>
<li>Interacting with other code non-welds related.</li>
<li>Interacting with view type layers of code that want to share the model. (Yew)</li>
</ul>
<br/>
<br/>
<br/>
<h3 id="vec-of-dbstate"><a class="header" href="#vec-of-dbstate">Vec of DbState</a></h3>
<p>These methods are <em>Method Extensions</em> added to <code>Vec&lt;DbState&lt;T&gt;&gt;</code>
when you include</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use welds::prelude::*;
<span class="boring">}</span></code></pre></pre>
<h4 id="into_inners"><a class="header" href="#into_inners">into_inners()</a></h4>
<p>returns a Vec of Models stripped of DbState.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pets: Vec&lt;DbState&lt;Pet&gt;&gt; = Pet::all().run(client.as_ref()).await?;
let pet: Vec&lt;Pet&gt; = pets.into_inners();
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case:</p>
<ul>
<li>Interacting with other code non-welds related.</li>
</ul>
<br/>
<h4 id="into_vms"><a class="header" href="#into_vms">into_vms()</a></h4>
<p>returns a Vec of Models stripped of DbState and wrapped in Arc.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pets: Vec&lt;DbState&lt;Pet&gt;&gt; = Pet::all().run(client.as_ref()).await?;
let pet: Vec&lt;Arc&lt;Pet&gt;&gt; = pets.into_vms();
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case:</p>
<ul>
<li>Interacting with other code non-welds related.</li>
<li>Interacting with view type layers of code that want to share the model. (Yew)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-relationships"><a class="header" href="#model-relationships">Model Relationships</a></h1>
<p>Welds supports several different types of relationships between models. By specifying these relationships, you can let the ORM know how your models are connected in the database.
This is used when making advanced queries across tables and across table updates</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Relationships are defined as attributes on your model’s struct. Each relationship attribute includes:</p>
<ol>
<li>A <strong>name</strong> (the field or logical name of the relationship).</li>
<li>A <strong>target type</strong> (the related model).</li>
<li>A <strong>foreign key</strong> or <strong>reference field</strong> (the column in this model or the related model that links them).</li>
</ol>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(BelongsTo(team, Team, "team_id"))]
<span class="boring">}</span></code></pre></pre>
<br/>
<br/>
<br/>
<br/>
<br/>
<h3 id="1-belongsto"><a class="header" href="#1-belongsto">1. BelongsTo</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(BelongsTo(team, Team, "team_id"))]
<span class="boring">}</span></code></pre></pre>
<p>Use BelongsTo when your model holds the foreign key referencing another model.</p>
<ul>
<li><strong>Name</strong> (first parameter): The name you want to give this relationship in your model (e.g., team).</li>
<li><strong>Target model</strong> (second parameter): The Rust struct you’re linking to (e.g., Team).</li>
<li><strong>Foreign key</strong> (third parameter): The column in this model that references the parent’s primary key (e.g., "team_id").</li>
</ul>
<p>Example use case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(welds::WeldsModel)]
#[welds(table = "players")]
#[welds(BelongsTo(team, Team, "team_id"))]
pub struct Player {
    #[welds(primary_key)]
    pub id: i32,
    pub name: String,
    pub team_id: i32,
}
<span class="boring">}</span></code></pre></pre>
<pre><code>The Player model has a team_id field referencing a Team record’s primary key.
</code></pre>
<br/>
<br/>
<br/>
<br/>
<br/>
<h3 id="2-hasmany"><a class="header" href="#2-hasmany">2. HasMany</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(HasMany(players, Player, "team_id"))]
<span class="boring">}</span></code></pre></pre>
<p>Use HasMany when the other model holds the foreign key.</p>
<ul>
<li><strong>Name</strong> (first parameter): The name of the relationship collection (e.g., players).</li>
<li><strong>Target model</strong> (second parameter): The child model (e.g., Player).</li>
<li><strong>Foreign key</strong> (third parameter): The column on the child model that references this model’s primary key (e.g., "team_id").</li>
</ul>
<p>Example use case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(welds::WeldsModel)]
#[welds(table = "teams")]
#[welds(HasMany(players, Player, "team_id"))]
pub struct Team {
    #[welds(primary_key)]
    pub id: i32,
    pub name: String,
}
<span class="boring">}</span></code></pre></pre>
<pre><code>The Team model can have many Player records, each storing team_id.
</code></pre>
<br/>
<br/>
<br/>
<br/>
<br/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks-1"><a class="header" href="#hooks-1">Hooks</a></h1>
<p>Welds allows you to attach functions (called "hooks") that run at specific points in the lifecycle of a model's interaction with the database.
These hooks enable you to perform actions such as validation, logging, or side-effectful tasks (e.g., sending notifications) before or after a model is created, updated, or deleted.</p>
<p><em><strong>Warning: hooks do not run on bulk operations</strong></em></p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Hook functions are regular Rust functions (or async functions) you register on your model using <code>#[welds(...)]</code> attributes.
Each function has access to the current model instance so it can inspect or even mutate fields (for "before" hooks).
In Welds, you can define hooks at these points:</p>
<ul>
<li>
<p><em><strong>BeforeCreate</strong></em>
Runs just before inserting the model as a new row in the database.</p>
</li>
<li>
<p><em><strong>AfterCreate</strong></em>
Runs immediately after the model is inserted in the database.</p>
</li>
<li>
<p><em><strong>BeforeUpdate</strong></em>
Runs right before an existing model is updated in the database.</p>
</li>
<li>
<p><em><strong>AfterUpdate</strong></em>
Runs right after an existing model is updated in the database.</p>
</li>
<li>
<p><em><strong>BeforeDelete</strong></em>
Runs just before an existing model is deleted from the database.</p>
</li>
<li>
<p><em><strong>AfterDelete</strong></em>
Runs immediately after an existing model is deleted from the database.</p>
</li>
</ul>
<br/>
<p>Because these hooks can alter or inspect your model right before or after it touches the database, they are a powerful way to inject your application-specific logic. Typical uses include:</p>
<ul>
<li><em><strong>Validation</strong></em>: Validate fields before insertion or update.</li>
<li><em><strong>Audit Logging</strong></em>: Output or record a log of changes.</li>
<li><em><strong>Timestamps</strong></em>: Automatically update timestamps or record user info.</li>
<li><em><strong>Notifications</strong></em>: Email or push notifications in the "after" hooks.</li>
<li><em><strong>Transformation</strong></em>: Adjust or sanitize data before persisting.</li>
</ul>
<h2 id="synchronous-vs-asynchronous-hooks"><a class="header" href="#synchronous-vs-asynchronous-hooks">Synchronous vs. Asynchronous Hooks</a></h2>
<p>By default, Welds treats hook functions as synchronous. You can, however, specify async = true in the attribute if your function is async:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[welds(AfterCreate(my_async_callback, async = true))]
<span class="boring">}</span></code></pre></pre>
<p>This allows you to perform asynchronous tasks, such as making web requests, sending notifications, etc., without blocking the thread.</p>
<p><em><strong>Warning: If you use an async hook within a transaction, you will be locking the table for the life of that async call. This should be avoided</strong></em></p>
<h2 id="hook-function-signatures"><a class="header" href="#hook-function-signatures">Hook Function Signatures</a></h2>
<p>Each hook receives different parameters depending on whether it’s a "before" or "after" hook:</p>
<br/>
<p>Before Hooks accept a mutable reference to the model, allowing you to change the model before writing to the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn before_create(model: &amp;mut MyModel) -&gt; welds::errors::Result&lt;()&gt; {
    // Possibly mutate fields or validate
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Returning errors
If a "before" hook fails and returns an error, Welds will stop the associated operation (create, update, or delete) and return the error to the caller.</p>
<br/>
<p>After Hooks accept an immutable reference to the model, as the change has already happened in the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn after_create(model: &amp;MyModel) {
    // Log or send a notification
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">Query</a></h1>
<p>In Welds a query or <code>QueryBuilder&lt;T&gt;</code> is an un-executed action to be preformed in the database. It is the root; the starting point for interactions with the database.</p>
<p>Bulk operations and single column selects are both accessible from a Query, so it really is the first place you should turn.</p>
<p>QueryBuilders can be accessed off of your models directly using functions such as  <code>where_col(...)</code> or <code>all()</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic---single-table-query"><a class="header" href="#basic---single-table-query">Basic - (single table query)</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Welds uses a builder-like API for constructing queries against your database models.
These queries are strongly typed, ensuring compile-time safety and making it clearer which columns and constraints are being used.
You can chain methods such as where_col(), order_by_asc(), and others to build increasingly complex queries without sacrificing readability.</p>
<h2 id="executing-queries"><a class="header" href="#executing-queries">Executing Queries</a></h2>
<p>Welds queries don't run in the database until you call <code>run</code> or <code>count</code>.
These calls build the required SQL, execute it in the database, and returns the corresponding data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let row_count = Model::all().count(client.as_ref()).await?;
let models = Model::all().run(client.as_ref()).await?;
<span class="boring">}</span></code></pre></pre>
<br/>
<br/>
<h2 id="where_col"><a class="header" href="#where_col">where_col(...)</a></h2>
<p>Use <code>where_col()</code> to filter rows based on one or more columns.
The closure you provide gives you typed access to the model’s fields, letting you specify constraints such
as <code>equal</code>, <code>not_equal</code>, <code>lt</code>, <code>lte</code>, <code>gt</code>, <code>gte</code>, <code>like</code>, etc. These filters are dependent on the underlying field type. (I.E. i32 doesn't have ilike)</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = Product::all()
    .where_col(|p| p.active.equal(true))
    .where_col(|p| p.name.like("%Cookie%"))
    .where_col(|p| p.price.not_equal(None));
<span class="boring">}</span></code></pre></pre>
<h4 id="list-of-filters-by-types"><a class="header" href="#list-of-filters-by-types">List of filters by types:</a></h4>
<ul>
<li>Everything
<ul>
<li>equal</li>
<li>not_equal</li>
<li>in_list (sql "in")</li>
</ul>
</li>
<li>Numbers (everything plus)
<ul>
<li>gt</li>
<li>lt</li>
<li>gte</li>
<li>lte</li>
</ul>
</li>
<li>Text (everything plus)
<ul>
<li>like</li>
<li>not_like</li>
<li>ilike</li>
<li>not_ilike</li>
</ul>
</li>
</ul>
<br/>
<br/>
<h2 id="limit"><a class="header" href="#limit">limit()</a></h2>
<p>Use <code>limit()</code> to restrict the number of rows returned by the query.
This is particularly useful for pagination or if you only need a certain number of records.</p>
<p>Usage</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let products = Product::all()
    .limit(10) // Only fetch up to 10 products
    .run(&amp;client)
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case</p>
<ul>
<li>Implementing pagination (in combination with offset() if needed).</li>
<li>Quickly previewing only a small subset of rows without fetching an entire table.</li>
<li>Performance optimization when you only need the first few rows.</li>
</ul>
<br/>
<br/>
<h2 id="offset"><a class="header" href="#offset">offset()</a></h2>
<p>Use <code>offset()</code> to skip over a set of rows
This is particularly useful for pagination.</p>
<p>Usage</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let products = Product::all()
    .limit(10) // Only fetch up to 10 products
    .offset(5) // skips the first 5 rows
    .run(&amp;client)
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>Typical Use Case</p>
<ul>
<li>Implementing pagination (in combination with limit()).</li>
</ul>
<br/>
<br/>
<h2 id="order_by_asc-and-order_by_desc"><a class="header" href="#order_by_asc-and-order_by_desc">order_by_asc() <em>and</em> order_by_desc()</a></h2>
<p>Use order_by_asc() and order_by_desc() to sort your query results in on a specified column. Calls to order_by and be compounded to make complex order by statements</p>
<p>Usage</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = Product::all()
    .order_by_desc(|x| x.created_at)
    .order_by_asc(|x| x.name);
<span class="boring">}</span></code></pre></pre>
<p>Variants</p>
<p><code>order_by_asc_null_first</code> and <code>order_by_desc_null_first</code> also exist to help with null values in your returning dataset</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced---cross-table-query"><a class="header" href="#advanced---cross-table-query">Advanced - (cross table query)</a></h1>
<p><em><em><strong>Not</strong></em> data from multiple tables. See <a href="./query_select.html">Custom Select</a> for that</em></p>
<p>Requirements: the following section requires that you have relationships setup on your models.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>In general when working with collections of data in code it is very common to see heavy use of
<code>map</code> and <code>filter</code> to transform a collection of data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_players: Vec&lt;&amp;str&gt; = players
    .filter(|p| p.goals &gt; 3)
    .map(|p| p.name)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p>This style of programming can be pleasant to write, and easy to read. However it is limited to the data you have already loaded into memory.
Wouldn't it be nice if you could write this style of code that ran in the database?
Welds tries to emulate this with the two functions <code>map_query</code> and <code>where_relation</code>.
While it isn't an exact one to one, It is a good mindset to help understand these two concepts.</p>
<h2 id="map_query"><a class="header" href="#map_query">map_query()</a></h2>
<p>Lets say I want to fetch data on one table, and use that data to lookup another table.</p>
<p>A <em><strong>very bad</strong></em> way of doing this might be.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let people = People::all().run(&amp;client).await?;
let addresses = people.map(|p| Address::find_by_id(&amp;client, p.address_id).await.unwrap() ).collect();

// or

let people = People::all().run(&amp;client).await?;
for person in people {
    let address = Address::find_by_id(&amp;client, p.address_id).await?;
}
<span class="boring">}</span></code></pre></pre>
<p>This will have very bad performance and will make many, many, many, database calls.
This is sometimes referred to as an "N+1 query".
Instead lets do the mapping in the database.</p>
<p>A <em><strong>much better</strong></em> way would be</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addresses = People::all().map_query(|p| p.addresses).run(&amp;client).await?;
<span class="boring">}</span></code></pre></pre>
<p>This does the equivalent mapping, but is much faster and easier to read.</p>
<p>This can of course be combined with other queries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get Bob's addresses
let addresses = People::where_col(|p| p.name.ilike("bob"))
    .map_query(|p| p.addresses).run(&amp;client).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="where_relation"><a class="header" href="#where_relation">where_relation()</a></h2>
<p>where_relation is the other side of this coin. It is a way to filter your data based on another query.</p>
<p>Lets say I have a complicated query of People.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get Bob's addresses
let people_query = People::all()
    ...
    .where_col(|p| p.created_at.gt(started_date))
    .where_col(|p| p.name.ilike("%b%"));
<span class="boring">}</span></code></pre></pre>
<p>It would be nice to be able to filter addresses on that list of people too.
You can do this with where_relation</p>
<p>for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addresses_query = Address::all().where_relation(|a| a.person, people_query);
<span class="boring">}</span></code></pre></pre>
<p>Again this can be combined with other queries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addresses_query = Address::where_col(|a| a.active)
    .where_relation(|a| a.person, people_query);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-select"><a class="header" href="#custom-select">Custom Select</a></h1>
<p>So far in the book, our models have been One-to-One matches with the underlying tables.
But what do we do if we want a subset of columns, or maybe data across tables.</p>
<p>Introducing <code>select</code> and <code>select_as</code></p>
<p><code>select</code> and <code>select_as</code> allow for the writing of queries that are disconnected from the concept of the underlying table.</p>
<p>This means:</p>
<ul>
<li>They can span multiple tables via joins</li>
<li>They can rename columns</li>
<li>They can pick only the parts of the data you care about.</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>A <em>Custom Select</em> involves two basic steps.</p>
<ol>
<li>Define a struct that represents the data you want out of the database.</li>
<li>Write a Query selecting parts from your existing models to extract that data.</li>
</ol>
<p>Lets assume we want this data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(WeldsModel)]
struct PlayerInfo {
    pub name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>Note: This model is not connected to a table and there isn't a table that looks like this.</p>
<h2 id="start-querying-single-column"><a class="header" href="#start-querying-single-column">Start Querying (single column)</a></h2>
<p>To get just the Player name we can start querying off of our existing Player Model that is wired up to the table.
Once we have a basic query we can select out only the columns we care about.</p>
<p>A query with a call to <code>select</code> returns generic rows, so we must call <code>collect_into()</code>
to collect them into our <code>PlayerInfo</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let player_query = Player::where_col(|p| p.goals.gt(3) );
let info_query = player_query.select(|p| p.name );
let infos: Vec&lt;PlayerInfo&gt; = info_query.run(&amp;client).await?.collect_into()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="with-more-data-joining-table"><a class="header" href="#with-more-data-joining-table">With more data (Joining table)</a></h2>
<p>What about if we want a list of player names, and their team names.
Lets first start by updating our output struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(WeldsModel)]
struct PlayerInfo {
    pub player_name: String,
    pub team_name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>This time around both models have a column called name. so we will need to rename them with <code>select_as</code>.
We can then start querying like before, but this time we will Join using our relationships we defined on the models <code>Player</code> and <code>Team</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let player_query = Player::where_col(|p| p.goals.gt(3) );

let info_query = order_query
    .select_as(|x| x.name, "player_name")
    .join( |p| p.team, Team::select_as(|p| p.name, "team_name") );

let infos: Vec&lt;PlayerInfo&gt; = info_query.run(&amp;client).await?.collect_into()?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include"><a class="header" href="#include">Include</a></h1>
<p><em>NOTE: when using include your data is read only</em></p>
<br />
<p>Fetch Models and their related objects.
Models are wired up to their related objects for ease of access.</p>
<p>Sometimes it's not the data that's important its the relationship.
A good example of this is a <code>select</code> with <code>opgroup</code>.</p>
<p>In the following Html snippit, we want both the <code>Food</code> model and the <code>FoodCategory</code> model.
We need to iterate over <code>FoodCategory</code> and find the relevant <code>Food</code> model.</p>
<p>In this example If we load our data with <code>include</code>, welds will automatically wire this up.</p>
<br />
<br />
<label for="hr-select">Your favorite food</label>
<select name="foods" id="hr-select">
  <option value="">Choose a food</option>
  <hr />
  <optgroup label="Fruit">
    <option value="apple">Apples</option>
    <option value="banana">Bananas</option>
    <option value="cherry">Cherries</option>
    <option value="damson">Damsons</option>
  </optgroup>
  <hr />
  <optgroup label="Vegetables">
    <option value="artichoke">Artichokes</option>
    <option value="broccoli">Broccoli</option>
    <option value="cabbage">Cabbages</option>
  </optgroup>
  <hr />
  <optgroup label="Meat">
    <option value="beef">Beef</option>
    <option value="chicken">Chicken</option>
    <option value="pork">Pork</option>
  </optgroup>
  <hr />
  <optgroup label="Fish">
    <option value="cod">Cod</option>
    <option value="haddock">Haddock</option>
    <option value="salmon">Salmon</option>
    <option value="turbot">Turbot</option>
  </optgroup>
</select>
<pre><code class="language-html">&lt;label for="hr-select"&gt;Your favorite food&lt;/label&gt; &lt;br /&gt;

&lt;select name="foods" id="hr-select"&gt;
  &lt;option value=""&gt;Choose a food&lt;/option&gt;
  &lt;hr /&gt;
  &lt;optgroup label="Fruit"&gt;
    &lt;option value="apple"&gt;Apples&lt;/option&gt;
    &lt;option value="banana"&gt;Bananas&lt;/option&gt;
    &lt;option value="cherry"&gt;Cherries&lt;/option&gt;
    &lt;option value="damson"&gt;Damsons&lt;/option&gt;
  &lt;/optgroup&gt;
  &lt;hr /&gt;
  &lt;optgroup label="Vegetables"&gt;
    &lt;option value="artichoke"&gt;Artichokes&lt;/option&gt;
    &lt;option value="broccoli"&gt;Broccoli&lt;/option&gt;
    &lt;option value="cabbage"&gt;Cabbages&lt;/option&gt;
  &lt;/optgroup&gt;
  &lt;hr /&gt;
  &lt;optgroup label="Meat"&gt;
    &lt;option value="beef"&gt;Beef&lt;/option&gt;
    &lt;option value="chicken"&gt;Chicken&lt;/option&gt;
    &lt;option value="pork"&gt;Pork&lt;/option&gt;
  &lt;/optgroup&gt;
  &lt;hr /&gt;
  &lt;optgroup label="Fish"&gt;
    &lt;option value="cod"&gt;Cod&lt;/option&gt;
    &lt;option value="haddock"&gt;Haddock&lt;/option&gt;
    &lt;option value="salmon"&gt;Salmon&lt;/option&gt;
    &lt;option value="turbot"&gt;Turbot&lt;/option&gt;
  &lt;/optgroup&gt;
&lt;/select&gt;
</code></pre>
<h2 id="loading-the-data"><a class="header" href="#loading-the-data">Loading the data</a></h2>
<p>Let us assume we have the two models <code>Food</code> and <code>FoodCategory</code>.
While you could select either model with the include and make it work,
we are iterating over <code>FoodCategory</code> first. Because of this, it is a better model to start with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::dataset::DataSet;

    let set: DataSet&lt;FoodCategory&gt; = FoodCategory::all()
        .include(|c| c.food)
        .run(client.as_ref())
        .await?;
<span class="boring">}</span></code></pre></pre>
<p>This leads into the next question.
What is a <code>DataSet</code> and how do I use it?</p>
<h2 id="datasett"><a class="header" href="#datasett">DataSet&lt;T&gt;</a></h2>
<p>Dataset is an iterate-able data collection like <code>Vec</code>.
It exists to maintain and access the related data between the models.</p>
<p>When you access a model from it, you get your model with a little extra.
The accessed data is wrapped in a special accessor struct that knows how to lookup its related objects.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::dataset::DataSet;

    let set: DataSet&lt;FoodCategory&gt; = FoodCategory::all()
        .include(|c| c.food)
        .run(client.as_ref())
        .await?;

    for category in set.iter() {
        println!("category: {}", category.name);

        // access the food for this spisiffic category
        let food_in_category = category.get(|x| x.food);
        for food in &amp;food_in_category {
            println!("food: {}", food.name);
        }
    }


<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-sql"><a class="header" href="#manual-sql">Manual SQL</a></h1>
<p>Custom SQL in WHERE Clauses
Sometimes you need more flexibility than the standard .where_col method provides.
For instance, you might want to perform a comparison between columns or use a database function in a way the query builder doesn’t directly support.
Welds offers two helper methods <code>where_manual</code> and <code>where_manual2</code> that let you drop in custom SQL snippets in your WHERE clauses.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Welds typically handles SQL generation for you. However, in advanced scenarios, you might need direct control over part of the WHERE clause.</p>
<p>The two functions covered here:</p>
<ul>
<li>where_manual</li>
<li>where_manual2</li>
</ul>
<p>Both let you inject custom SQL strings. They differ slightly in how they reference columns and in how the snippet is anchored in the <code>WHERE</code> condition.</p>
<p>Important Notes:</p>
<ol>
<li><em><strong>Use <code>?</code> for parameters.</strong></em> Welds will substitute them with the correct syntax (<code>$1</code>, <code>?</code>, or <code>@p1</code> depending on your database).</li>
<li><em><strong>Use <code>$</code> as a placeholder for the table alias.</strong></em> At runtime, Welds replaces <code>$</code> with the actual table alias (e.g., <code>t1</code>).
For instance, <code>$.price1</code> might become <code>t1.price1</code>.</li>
</ol>
<p>where_manual
Description</p>
<h2 id="where_manual"><a class="header" href="#where_manual">where_manual</a></h2>
<p>where_manual adds custom SQL to the right side of a clause while anchoring it to a specific column in your model.
Internally, it references the column you choose (in the lambda) and appends a user-supplied custom snippet.</p>
<p>Usage:</p>
<p>Imagine you have a table thing with two integer fields price1 and price2.
You want to return rows where price1 is greater than price2 + 5.
We can’t express this directly with standard comparisons, so we use where_manual:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = Thing::all().where_manual(|c| c.price1, " &gt; ($.price2 + ?) * ?", (1, 0.19) );
<span class="boring">}</span></code></pre></pre>
<p>The params for where_manual are automatically converted from a tuple of whatever size.</p>
<h2 id="where_manual2"><a class="header" href="#where_manual2">where_manual2</a></h2>
<p>where_manual2 gives you full control over a custom SQL snippet in the WHERE clause without requiring an anchor column.
This is useful for comparing multiple columns or more elaborate function calls.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = Thing::all().where_manual2("$.price1 + $.price2 &gt; ?", (33,) );
<span class="boring">}</span></code></pre></pre>
<p>The params for where_manual2 are automatically converted from a tuple of whatever size.</p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>There are a couple other <code>*_manual</code> functions in the QueryBuilder with the purpose of allowing small manual SQL snippets in the query.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-sql"><a class="header" href="#raw-sql">Raw SQL</a></h1>
<p>Welds has the mindset that you should be able to drop down to SQL if you need it.
We provide several ways to use SQL snipits in your queries, but this chapter is how to bypass the QueryBuilder altogether.</p>
<p>Your <code>client</code> from when you connected has everything on it that you could need.
Most likely you have connected with a generic <code>AnyClient</code> connection. <code>AnyClient</code>
and the four specific variants all implement the two traits <code>welds_connections::Client</code> and <code>welds_connections::TransactStart</code>.
These two trans are the common way to tall to any database.</p>
<br/>
<p>It should be noted while the interface is common between the different database backends, the database backend all expect their own slightly different flavor of SQL.
If you are writing raw SQL, you will need to write it for all the backends you would like to support.</p>
<h2 id="execute"><a class="header" href="#execute">execute</a></h2>
<p>If you aren't expecting to get any data back from the database, <code>execute</code> is what you are looking for.
You pass in raw SQL with SQL parameters, and the database runs it for you.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::prelude::*;
    let client = welds::connections::connect(connection_string).await?;
    let text: String = "I'm a String".to_owned();
    client.execute("select ?, ?", &amp;[&amp;2, &amp;text]).await?;
<span class="boring">}</span></code></pre></pre>
<p>There are a couple things worth pointing out in this example.</p>
<ol>
<li>Make sure you are including the <code>prelude</code>. It includes the traits you need</li>
<li>Those parameters are a little crazy looking. Are They mixing types?</li>
</ol>
<p>The parameters are actually just a slice of borrowed <code>dyn Param</code> (can be sent to database).
This is why all parts of it are borrowed <code>&amp;</code>.</p>
<p>A much more verbose way of writing this might look like this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::prelude::*;
    use welds::connections::Param;
    let mut params: Vec&lt;&amp;(dyn Param + Sync)&gt; = Vec::default();
    let text: String = "I'm a String".to_owned();
    params.push(&amp;2);
    params.push(&amp;text);
    client.execute("select ?, ?;", &amp;params).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="fetch_rows-into-model"><a class="header" href="#fetch_rows-into-model">fetch_rows, Into Model</a></h2>
<p><code>fetch_rows</code> works exactly like <code>execute</code> except it returns a <code>Vec&lt;Row&gt;</code>.
All welds models impl <code>TryFrom&lt;Row&gt;</code>.
This allows you to read out raw values from each row or map them into a <code>WeldsModel</code>.</p>
<p>The welds model</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(WeldsModel)]
struct Car {
    id: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>Running the raw SQL and mapping into your struct</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::prelude::*;
    let client = welds::connections::connect(connection_string).await?;
    let rows = client.execute("select id from cars", &amp;[]).await?;
    let cars: Vec&lt;Car&gt; = rows.collect_into()?;
<span class="boring">}</span></code></pre></pre>
<p>There are a couple things to note about this example.</p>
<ol>
<li>The mapping into the model is done by <em><strong>column name</strong></em>.
Make sure the field name on your model matches what is being selected.</li>
<li><code>collect_into()</code> is a helper method extension added to <code>Vec&lt;Row&gt;</code></li>
</ol>
<h2 id="fetch_rows-by-hand"><a class="header" href="#fetch_rows-by-hand">fetch_rows, By Hand</a></h2>
<p>If you are just reading a single value like a count or total, it might be easier to avoid a welds model.
Here are two examples that read a value directly from a row.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::prelude::*;
    let rows = client.fetch_rows("select 1 + 1 as total;", &amp;[]).await?;
    let first_row = rows.first().unwrap();
    let total: i32 = first_row.get("total")?;
    println!("Total: {total}");
<span class="boring">}</span></code></pre></pre>
<p>You can read values by position in the row with <code>get_by_position</code>.
Note it is zero based.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::prelude::*;
    let rows = client.fetch_rows("select 1 + 2;", &amp;[]).await?;
    let first_row = rows.first().unwrap();
    let total: i32 = first_row.get_by_position(0)?;
    println!("Total: {total}");
<span class="boring">}</span></code></pre></pre>
<h2 id="fetch-many"><a class="header" href="#fetch-many">Fetch Many</a></h2>
<p>Last we have one more function that is used by welds internally for optimizations and you can use it too if you wish.
<code>fetch_many</code> takes in a slice of <code>welds_connections::Fetch</code> (pairs of sql and params).</p>
<p>This is specifically useful when you want to force multiple database calls onto the same connection in a database pool.
There are a couple niche use cases you might want to do this, but most likely <code>fetch_rows</code> is what you want.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::prelude::*;
    use welds::connections::Fetch;

    let fetches = vec![
        Fetch {
            sql: "select 1",
            params: &amp;[],
        },
        Fetch {
            sql: "select 2",
            params: &amp;[],
        },
    ];

    let groups_of_rows = client.fetch_many(&amp;fetches).await?;
    for rows in groups_of_rows {
        // work with each individual set of rows
    }

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bulk"><a class="header" href="#bulk">Bulk</a></h1>
<p>One truth across all databases is single database operations are slow.
Using operations that effect multiple rows simultaneously is a much faster way of interacting with the database.</p>
<p>This is unfortunate for ORMs since ORMs usually edit/create only one row at a time. <code>Welds</code> has a solution to this problem.</p>
<p>With welds you get <a href="./bulk_insert.html">Bulk Insert</a>, <a href="./bulk_update.html">Bulk Update</a>, and <a href="./bulk_delete.html">Bulk Delete</a>.</p>
<br/>
<br/>
<p><em><strong>NOTE: bulk operations do NOT trigger model hooks</strong></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bulk-insert"><a class="header" href="#bulk-insert">Bulk Insert</a></h1>
<p>When adding a lot of data into your database using a bulk insert can save a lot of time.
This has to do with the way databases work, and is true at the database level.</p>
<p>There are many different ways to "Bulk Insert" into a database, Welds tries to provide a common interface for the best option for each of its backends.</p>
<h2 id="bulk_insert__"><a class="header" href="#bulk_insert__">bulk_insert(_,_)</a></h2>
<p>The <code>bulk_insert</code> function is that common interface. It is pretty strait forward taking in a <a href="./fundamentals.html#weldsclient">Client</a> and a slice of <code>WeldsModels</code></p>
<p>bulk_insert is not accessible via the query builder like other operations. You will need to include it with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::query::insert::bulk_insert;
<span class="boring">}</span></code></pre></pre>
<p>First build a slice of data that you want to insert.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(WeldsModel)]
#[welds(table = "products")]
pub struct Product {
    #[welds(primary_key)]
    pub id: i32,
    pub name: String,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut products: Vec&lt;Product&gt; = Vec::default();
    for i in (0..1000) {
        products.push( Product {
            id: 0,
            name: format!("product #{}", i)
        });
    }
<span class="boring">}</span></code></pre></pre>
<br/>
<p>Things to notice:</p>
<ol>
<li>The column <code>id</code> is marked as a <code>primary_key</code>. Typically in welds
if the primary_key field is <code>Default::default()</code> it is ignored when inserting.
Here in Bulk insert the primary_key is <em><strong>ALWAYS</strong></em> ignored.
If you want to insert a primary_key column, you will need to make a new model struct and NOT mark the primary_key as primary_key</li>
<li>DbState is not used with bulk operations</li>
</ol>
<p>You can now insert your data with a call to <code>bulk_insert</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use welds::query::insert::bulk_insert;
    bulk_insert(&amp;client, &amp;products).await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bulk-update"><a class="header" href="#bulk-update">Bulk Update</a></h1>
<p>Bulk update is a way to write SQL update statements with in welds.</p>
<p>Bulk updates are accessible on <a href="./query.html">QueryBuilder&lt;T&gt;</a>. To start a bulk update you can call one <code>set</code> operations on your query.
<code>set</code>, <code>set_col</code>, <code>set_null</code>, <code>set_manual</code></p>
<br/>
<h2 id="set--set_col"><a class="header" href="#set--set_col">set / set_col</a></h2>
<p><code>set</code> and <code>set_col</code> are functionally identical.
They just provide two coding flavors to the same underlying set operation.</p>
<p>To use them start off with a Query just like you would to select your data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let q = Product::where_col(|x| x.name.ilike("% - discontinued") );
<span class="boring">}</span></code></pre></pre>
<p>You can then call <code>set</code> or <code>set_col</code> to convert this query into a bulk update</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let q = Product::where_col(|x| x.name.ilike("% - discontinued") );

    q.set(|o| o.hidden, true).run(&amp;client).await?;
    // or
    q.set_col(|o| o.hidden.equal(true) ).run(&amp;client).await?;

<span class="boring">}</span></code></pre></pre>
<h2 id="set_null"><a class="header" href="#set_null">set_null</a></h2>
<p><code>set_null</code> is just a short hand for <code>set(_, None)</code>.
It is nice in that it makes your code cleaner to read.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let q = Product::where_col(|x| x.name.ilike("% - discontinued") );

    q.set(|o| o.hidden, true).run(&amp;client).await?;
    // or
    q.set_col(|o| o.hidden.equal(true) ).run(&amp;client).await?;

<span class="boring">}</span></code></pre></pre>
<h2 id="set_manual"><a class="header" href="#set_manual">set_manual</a></h2>
<p>Sometimes you need to set a column based on another columns value; for example a calculation.
In this scenario <code>set_manual</code> is what you are looking for.
It functions in the same way as the other <a href="./query_sql.html">manual sql</a> calls</p>
<p>To use it start off with a query,
but this time you can insert a snippit of generic SQL to set the columns value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Order::all()
        .set_manual(|x| x.sell_price, "$.sell_price + ?", (88,))
        .run(&amp;client).await?;
<span class="boring">}</span></code></pre></pre>
<p>NOTE: use <code>?</code> for all database backends. It will be translated appropriately for the backends being called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bulk-delete"><a class="header" href="#bulk-delete">Bulk Delete</a></h1>
<p>Bulk delete is a way to write SQL delete statements with in welds.
Bulk delete is accessed on <a href="./query.html">QueryBuilder&lt;T&gt;</a> via <code>delete</code>.</p>
<p>To use bulk delete call delete with the client.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Product::all()
        .where_col(|x| x.name.ilike("% - discontinued") )
        .delete(&amp;client).await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrations"><a class="header" href="#migrations">Migrations</a></h1>
<p>Welds has built in migrations that offer a couple nice benefits SQL script style migrations do not.</p>
<ol>
<li>You can write them once and they work with all backends</li>
<li>Welds migrations are database aware, so they automatically generate down migrations.</li>
<li>You can always fallback to raw SQL style migrations with the <code>Manual</code> migrations struct.</li>
</ol>
<p>To use migrations make sure the migrations feature flag is enabled.</p>
<pre><code class="language-bash">cargo add welds --feature=migrations
</code></pre>
<h2 id="common-setup--layout"><a class="header" href="#common-setup--layout">Common Setup / layout</a></h2>
<p>Feel free to layout migrations in your project how you see fit, but if you are looking for a simple starting place:</p>
<ol>
<li>make a migrations module <code>src/migrations/mod.rs</code></li>
<li>add an <code>up</code> style function to run all your migrations. migrations that have already executed will be skipped.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*  ./src/migrations/mod.rs  */

use welds::errors::Result;
use welds::migrations::prelude::*;

pub async fn up(client: &amp;dyn welds::TransactStart) -&gt; Result&lt;()&gt; {
    let list: Vec&lt;MigrationFn&gt; = vec![
        m20250210064356_create_table_dogs::step,
    ];
    welds::migrations::up(client, list.as_slice()).await?;
    Ok(())
}

mod m20250210064356_create_table_dogs;
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>keep adding your migrations as sub-modules as you need them.</li>
<li>call <code>crate::migrations::up(&amp;client).await?;</code> when your app boots.</li>
</ol>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p><code>welds::migrations::Types</code> is an Enum of generic sounding types that welds knows how to translate into Rust code and each database backend.
Stick to these types if you can. Sometimes you have an odd SQL Type you need to work with.
You can do so with <code>Types::Raw(XXX)</code>. This variant allows full control of what type is used in SQL.</p>
<h2 id="create-table"><a class="header" href="#create-table">Create Table</a></h2>
<p><code>create_table</code> is a function to generate a migration to create a table.
It is a build pattern style call.
Inside each call to column lambda is a nested build pattern style call for each column.</p>
<p>A vary plain example might look like this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use welds::errors::Result;
use welds::migrations::prelude::*;

pub(super) fn step(_state: &amp;TableState) -&gt; Result&lt;MigrationStep&gt; {
    let m = create_table("dogs")
        .id(|c| c("id", Type::IntBig))
        .column(|c| c("name", Type::String))
        .column(|c| c("wags", Type::Int));
    Ok(MigrationStep::new("m20250210064356_create_table_dogs", m))
}
<span class="boring">}</span></code></pre></pre>
<p>By default all columns are not null. We can change this by adding onto the columns lambda call.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let m = create_table("dogs")
        .id(|c| c("id", Type::IntBig))
        .column(|c| c("name", Type::String).is_null())
        .column(|c| c("wags", Type::Int));
}
<span class="boring">}</span></code></pre></pre>
<p>Notable column settings:</p>
<ul>
<li><em><strong>is_null()</strong></em> sets the column as nullable</li>
<li><em><strong>with_index()</strong></em> adds an index to the column</li>
<li><em><strong>with_index_name(&amp;str)</strong></em> adds an index to the column, with a name that you provide</li>
<li><em><strong>with_unique_index()</strong></em> Adds a unique constraint on this column</li>
<li><em><strong>create_foreign_key(_,_,_)</strong></em> Adds a foreign key (foreign_table, foreign_column, delete_behavior)</li>
</ul>
<h2 id="alter-table---alter-columns---delete-table"><a class="header" href="#alter-table---alter-columns---delete-table">Alter Table - Alter Columns - Delete Table</a></h2>
<p>Modifications to tables including table drops are accessible from a call to <code>change_table</code>.</p>
<h3 id="dropping-a-table"><a class="header" href="#dropping-a-table">Dropping a table</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn step(state: &amp;TableState) -&gt; Result&lt;MigrationStep&gt; {
    let m = change_table(state, "dogs")?.drop();
    Ok(MigrationStep::new("m20250210064357_drop_table_dogs", m))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-column"><a class="header" href="#add-column">Add Column</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn step(state: &amp;TableState) -&gt; Result&lt;MigrationStep&gt; {
    let alter = change_table(state, "dogs")?;
    let m = alter.add_column("belly_rubs", Type::Int);
    Ok(MigrationStep::new("m20250210064357_add_column", m))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="change-a-column"><a class="header" href="#change-a-column">Change a column</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn step(state: &amp;TableState) -&gt; Result&lt;MigrationStep&gt; {
    let alter = change_table(state, "dogs")?;
    let m = alter.change("belly_rubs")
        .to_type( Type::IntBig )
        .null() // make nullable
        .rename("rubs");
    Ok(MigrationStep::new("m20250210064357_alter_column", m))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="manual-sql-1"><a class="header" href="#manual-sql-1">Manual SQL</a></h2>
<p>Welds always tries to provide a fallback for a manual option.
Migrations are no exception.
You can always write manual raw SQL to make database changes if needed.</p>
<p>Manual migrations are ran within a transaction and support running multiple commands separated by a semicolon ";"</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use welds::errors::Result;
use welds::migrations::prelude::*;
use welds::migrations::Manual;

fn step(state: &amp;TableState) -&gt; Result&lt;MigrationStep&gt; {
    let m = Manual::up("DROP TABLE dogs")
        .down("CREATE TABLE dogs ( id SERIAL PRIMARY KEY )");
    Ok(MigrationStep::new("m20250210064357_manual_dogs", m))
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
